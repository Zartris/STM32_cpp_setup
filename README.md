# STM32 C++ Project Template for CubeMX

This repository provides a template for integrating C++ code into STM32 projects generated by STM32CubeMX. It ensures compatibility with CubeMX's C-based `main()` function while allowing you to develop your application logic in C++.

## Prerequisites

*   **STM32CubeMX:** Used to generate the base project code, including HAL drivers and initial configurations.
*   **ARM GCC Toolchain:** A cross-compiler for ARM Cortex-M processors. Make sure it's installed and the path is added to your environment variables.
*   **CMake:** The cross-platform build system. You'll need to have it installed.
*   **An STM32CubeMX Generated Project:**  You must have an existing STM32 project set up using CubeMX for your specific microcontroller.
*   **Ninja or make:** To use cmake, you need a build system.
*   **UART:** Enable at least one UART port for the logger. (For H723ZG uart3 is the simlink)

## Project Structure

This template uses the following directory structure to organize the project:
stm32-cpp-template/
 ├── .vscode/ # Optional: VS Code settings 
 ├── App/ # Your C++ application code 
 │  ├── Inc/ # Application header files (app.hpp, logger.hpp) 
 │  └── Src/ # Application source files (app.cpp) 
 ├── Core/ # CubeMX generated files (HAL, main.c, etc.) 
 │  ├── Inc/ # Header files (main.h, mainCpp.h) 
 │  └── Src/ # Source files (main.c) 
 ├── CMakeLists.txt % Main CMake file
 └── README.md # Project documentation

## Project Structure Additions

You will need to add the following to your project:

*   **`Core/Inc/mainCpp.h`:** Header file for the C++ entry point.
*   **`App/Src/app.cpp`:** C++ source file containing your application code.
*   **`App/Inc/app.hpp`:** C++ header file containing the class definition.
*   **`App/Inc/logger.hpp`:** Header file for the `Logger` class (contains the entire class definition).

## C++ Integration Steps

These are the essential steps to set up your CubeMX project for C++ development:

1.  **Create the `App` Folder:**
    *   Create a top-level folder named `App`.
    *   Inside `App`, create two subfolders: `Inc` and `Src`.

2.  **Create `App/Inc/app.hpp`:**
    *   Create `app.hpp` inside the `App/Inc` directory.
    *   This file contains the definition of your main application class (typically named `App`).

    ```c++
    #pragma once
    #include "logger.hpp"

    class App
    {
    public:
        // Singleton pattern
        static App &getInstance()
        {
            static App instance;
            return instance;
        }
        bool init();
        void run();

    private:
        UARTLogger m_log{&huart2};
    };
    ```

3.  **Create `App/Src/app.cpp`:**
    *   Create `app.cpp` inside the `App/Src` directory.
    *   This file contains the `mainCpp()` function, your C++ application's entry point, and the implementation of the `App` class.

    ```c++
    #include "main.h"
    #include "app.hpp"
    #include "i2c.h"

    #ifdef __cplusplus
    extern "C"
    {
    #endif
        void mainCpp(void)
        {
            App &app = App::getInstance();
            if (!app.init())
            {
                Error_Handler();
            }
            while (1)
            {
                app.run();
            }
        }
        void handleErrorCpp(void)
        {
            Error_Handler();
        }
    #ifdef __cplusplus
    }
    #endif

    App App::instance;

    // This is the C++ code that will run in the main loop.
    bool App::init()
    {
        App &app = App::getInstance();
        app.m_log.setLogLevel(LogLevel::log_DEBUG);
        app.m_log.info("Starting init");
        // Place your initialization code here.
        return true;
    }

    void App::run()
    {
        App &app = App::getInstance();
        app.m_log.debug("running");
        // Place your main application loop logic here.
        HAL_Delay(100);
    }
    ```

4.  **Create `Core/Inc/mainCpp.h`:**
    *   Create `mainCpp.h` inside the `Core/Inc` directory.
    *   This header provides the necessary `extern "C"` declarations to make your C++ functions callable from C code (specifically, from `main.c`).

    ```c++
    #pragma once
    #ifdef __cplusplus
    extern "C"
    {
    #endif
        void mainCpp(void);
        void handleErrorCpp(void);
    #ifdef __cplusplus
    }
    #endif
    ```

5.  **Create `App/Inc/logger.hpp`**
    *   Create `logger.hpp` in the `App/Inc` folder.
    *   This file contains the entire `Logger` and `UARTLogger` class definition. The code for this file is provided above.

6.  **Modify `Core/Src/main.c`:**
    *   Open the `main.c` file generated by CubeMX.
    *   Include `mainCpp.h` at the top of the file:

    ```c
    /* USER CODE BEGIN Includes */
    #include "mainCpp.h"
    /* USER CODE END Includes */
    ```

    *   Call `mainCpp()` just before the infinite loop. remove the loop as it is now inside the mainCpp function in app.cpp.

    ```c
    int main(void)
    {
        // ... CubeMX-generated initialization code ...

        /* Infinite loop */
        /* USER CODE BEGIN WHILE */
        mainCpp();
        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
        /* USER CODE END 3 */
    }
    ```

## Explanation

*   **`App/Inc/app.hpp` & `App/Src/app.cpp`:** These files contain your C++ application code.
    *   `App::init()` is responsible for the initialization of your classes.
    *   `App::run()` is the main run logic.
    *   `mainCpp()` is the main cpp function. It will call your app init and run functions.
    *   `handleErrorCpp()` will call the error handler.
    *   A singleton class App is used here.
    * `m_log` is an instance of the UARTLogger that is used to print to uart.
*   **`Core/Inc/mainCpp.h`:** This header file declares `mainCpp()` and `handleErrorCpp()` using `extern "C"`. This is crucial for calling C++ code from C.
*   **`Core/Src/main.c`:** This file is generated by CubeMX. You modify it to include `mainCpp.h` and to call the `mainCpp()` function.
*   **`App/Inc/logger.hpp`:** This file contains the entire implementation of the `Logger` and `UARTLogger` classes, including the `enum LogLevel`.

## Tips and Tricks

*   **Enabling Float Printing:** To enable the use of floating-point numbers (e.g., `%f`) in `printf`, you need to add the following linker option to your `CMakeLists.txt` (or equivalent build configuration):

    ```cmake
    target_link_options(${CMAKE_PROJECT_NAME} PRIVATE
        -u _printf_float
    )
    ```
    This is not required to run the project. But if you need to print floats, this is how it is done.
    This option will link the necessary code from the standard library to make this work. Keep in mind that including floating-point support can increase the flash usage significantly.
*   **Using the Logger:**
    *   Include the `logger.hpp` file in your source file: `#include "logger.hpp"`.
    *  Create a UARTLogger object in your class.
    * set the `logLevel` with `setLogLevel()`. The log will only print if the log level is less or equal.
    *   The logger has different log levels that can be used:
        *   `m_log.debug("Your log")`
        *   `m_log.info("Your log")`
        *   `m_log.warning("Your log")`
        *   `m_log.error("Your log")`
    * These will log your message to the defined UART.

## Key Considerations

*   **CubeMX Regeneration:** If you regenerate code with CubeMX, it will likely overwrite `main.c`. Be sure to reapply the `mainCpp.h` include and the `mainCpp()` call. You can copy paste the modified part, or make a copy of the modified file.
*   **C++ Entry Point:** `mainCpp()` in `app.cpp` is the entry point for your C++ code.
*   **Error Handling**: If an error occurs, the `handleErrorCpp()` will be called, which calls the `Error_Handler()` method.
*   **App folder**: All your code should be in the app folder.
*   **CMake**: The project is build with cmake, even though there are no explanations on how to use it.
*   **New files**: If new files are created, they should be included in the cmakelist.
* **UART**: The Logger is using the huart2 to print, you must enable it in cubemx.
* **Logger**: The logger is now a class that must be instantiated.